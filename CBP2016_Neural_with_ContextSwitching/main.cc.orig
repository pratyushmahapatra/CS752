///////////////////////////////////////////////////////////////////////
//  Copyright 2015 Samsung Austin Semiconductor, LLC.                //
///////////////////////////////////////////////////////////////////////

//Description : Main file for CBP2016 

#include <assert.h>
#include <stdlib.h>
#include <string.h>
#include <map>
using namespace std;

#include "utils.h"
//#include "bt9.h"
#include "bt9_reader.h"
//#include "predictor.cc"
#include "predictor.h"


#define COUNTER     unsigned long long
UINT64 counter[20] = 0;


void CheckHeartBeat(UINT64 numIter, UINT64 numMispred)
{
  UINT64 dotInterval=1000000;
  UINT64 lineInterval=30*dotInterval;

 UINT64 d1K   =1000;
 UINT64 d10K  =10000;
 UINT64 d100K =100000;
 UINT64 d1M   =1000000; 
 UINT64 d10M  =10000000;
 UINT64 d30M  =30000000;
 UINT64 d60M  =60000000;
 UINT64 d100M =100000000;
 UINT64 d300M =300000000;
 UINT64 d600M =600000000;
 UINT64 d1B   =1000000000;
 UINT64 d10B  =10000000000;


//  if(numIter % lineInterval == 0){ //prints line every 30 million branches
//    printf("\n");
//    fflush(stdout);
//  }
  if(numIter == d1K){ //prints MPKI after 100K branches
    printf("  MPKBr_1K         \t : %10.4f",   1000.0*(double)(numMispred)/(double)(numIter));   
    fflush(stdout);
  }

  if(numIter == d10K){ //prints MPKI after 100K branches
    printf("  MPKBr_10K         \t : %10.4f",   1000.0*(double)(numMispred)/(double)(numIter));   
    fflush(stdout);
  }
  
  if(numIter == d100K){ //prints MPKI after 100K branches
    printf("  MPKBr_100K         \t : %10.4f",   1000.0*(double)(numMispred)/(double)(numIter));   
    fflush(stdout);
  }
  if(numIter == d1M){
    printf("  MPKBr_1M         \t : %10.4f",   1000.0*(double)(numMispred)/(double)(numIter)); 
    fflush(stdout);
  }

  if(numIter == d10M){ //prints MPKI after 100K branches
    printf("  MPKBr_10M         \t : %10.4f",   1000.0*(double)(numMispred)/(double)(numIter));   
    fflush(stdout);
  }

  if(numIter == d30M){ //prints MPKI after 100K branches
    printf("  MPKBr_30M         \t : %10.4f",   1000.0*(double)(numMispred)/(double)(numIter));   
    fflush(stdout);
  }

  if(numIter == d60M){ //prints MPKI after 100K branches
    printf("  MPKBr_60M         \t : %10.4f",   1000.0*(double)(numMispred)/(double)(numIter));   
    fflush(stdout);
  }

  if(numIter == d100M){ //prints MPKI after 100K branches
    printf("  MPKBr_100M         \t : %10.4f",   1000.0*(double)(numMispred)/(double)(numIter));   
    fflush(stdout);
  }
  
  if(numIter == d300M){ //prints MPKI after 100K branches
    printf("  MPKBr_300M         \t : %10.4f",   1000.0*(double)(numMispred)/(double)(numIter));   
    fflush(stdout);
  }

  if(numIter == d600M){ //prints MPKI after 100K branches
    printf("  MPKBr_600M         \t : %10.4f",   1000.0*(double)(numMispred)/(double)(numIter));   
    fflush(stdout);
  }

  if(numIter == d1B){ //prints MPKI after 100K branches
    printf("  MPKBr_1B         \t : %10.4f",   1000.0*(double)(numMispred)/(double)(numIter));   
    fflush(stdout);
  }
  
  if(numIter == d10B){ //prints MPKI after 100K branches
    printf("  MPKBr_10B         \t : %10.4f",   1000.0*(double)(numMispred)/(double)(numIter));   
    fflush(stdout);
  }
 
}//void CheckHeartBeat

// usage: predictor <trace>

int main(int argc, char* argv[]){
  
  if (argc != 3) {
    printf("usage: %s <no. of processes> <tracelist>\n", argv[0]);
    exit(-1);
  }
  
  ///////////////////////////////////////////////
  // Init variables
  ///////////////////////////////////////////////
    
    PREDICTOR  *brpred = new PREDICTOR();  // this instantiates the predictor code
  ///////////////////////////////////////////////
  // read each trace recrod, simulate until done
  ///////////////////////////////////////////////
    int procs= argv[1];
    std::string trace_path[20];
    std::string total_inst[20];
    std::string total_br_inst[20];
    UINT64 total_instruction_counter[20] =0; 
    UINT64 current_instruction_counter[20] = 0;
    UINT64 branch_instruction_counter[20]=0;
    UINT64 numMispred[20]=0;
    UINT64 cond_branch_instruction_counter[20]=0;
    UINT64 uncond_branch_instruction_counter[20]=0;
    bt9::BT9Reader *bt9_reader;
    std::string key1 = "total_instruction_count:";	
    std::string key2 = "branch_instruction_count:";
    auto it_2 = bt9_reader_2.begin();
    typedef decltype(it_2) branch;
    branch it[20];
    branch resume[20]; 
    for(i=0; i< procs; i++){
	trace_path[i] =  //read the tracefile names from the tracelist;
	bt9_reader[i]=BT9Reader(trace_path[i]);
        bt9_reader[i].header.getFieldValueStr(key1, total_inst[i]);
 	total_instruction_counter[i] = std::stoull(total_inst[i], nullptr, 0);	
        bt9_reader[i].header.getFieldValueStr(key2, total_br_inst[i]);	
        branch_instruction_counter[i] = std::stoull(total_br_inst[i], nullptr, 0);	
	cond_branch_instruction_counter[i]=0;
	uncond_branch_instruction_counter[i]=0;
	it[i]=bt9_reader[i].begin();
	resume[i]=it[i];
	}
    
//ver2    UINT64     numMispred_btbMISS =0;  
//ver2    UINT64     numMispred_btbANSF =0;  
//ver2    UINT64     numMispred_btbATSF =0;  
//ver2    UINT64     numMispred_btbDYN =0;  

//ver2     UINT64 btb_ansf_cond_branch_instruction_counter=0;
//ver2     UINT64 btb_atsf_cond_branch_instruction_counter=0;
//ver2     UINT64 btb_dyn_cond_branch_instruction_counter=0;
//ver2     UINT64 btb_miss_cond_branch_instruction_counter=0;

//ver2    ///////////////////////////////////////////////
//ver2    // model simple branch marking structure
//ver2    ///////////////////////////////////////////////
//ver2    std::map<UINT64, UINT32> myBtb; 
//ver2    map<UINT64, UINT32>::iterator myBtbIterator;
//ver2
//ver2    myBtb.clear();
   
  ///////////////////////////////////////////////
  // read each trace record, simulate until done
  ///////////////////////////////////////////////

      OpType opType[20];
      UINT64 PC[20];
      bool branchTaken[20];
      UINT64 branchTarget[20];
      UINT64 numIter[20] = 0;
      UINT64 counter[20] = 0;
      
     
      for (auto it = bt9_reader.begin(); it != bt9_reader.end(); ++it) {
        CheckHeartBeat(++numIter, numMispred); //Here numIter will be equal to number of branches read
	//SUCHITA
        printf("In trace 1 : Counter, numiter, numMispredict 1, Counter_2, numiter2, numMispredict2 = %d, %d, %d, %d, %d, %d \n", counter, numIter, numMispred, counter_2, numIter_2, numMispred_2);
        if((counter != 0) && (counter % 10000 == 0)){
		printf("Context Switching now! P0 mispredict rate before switching is \t : %10.4f \n",   1000.0*(double)(numMispred)/(double)(numIter));
    		fflush(stdout);
 	        if(counter_2 != 0)
			it_2 = resume_it;
		
		for ( ; it_2 != bt9_reader_2.end(); ++it_2) {
			printf("entering second trace" );
        	CheckHeartBeat(++numIter_2, numMispred_2);
			printf("In Trace 2: Counter, numiter, numMispredict 1, Counter_2, numiter2, numMispredict2 = %d, %d, %d, %d, %d, %d \n", counter, numIter, numMispred, counter_2, numIter_2, numMispred_2);
			try {
		        bt9::BrClass br_class_2 = it_2->getSrcNode()->brClass();
                        
			//JD2_2_2016 break down branch instructions into all possible types
          		opType_2 = OPTYPE_ERROR;


          		if ((br_class_2.type == bt9::BrClass::Type::UNKNOWN) && (it_2->getSrcNode()->brNodeIndex())) { //only fault if it isn't the first node in the graph (fake branch)
            		opType_2 = OPTYPE_ERROR; //sanity check
          		}
          		else if (br_class_2.type == bt9::BrClass::Type::RET) {
            		if (br_class_2.conditionality == bt9::BrClass::Conditionality::CONDITIONAL)
              		opType_2 = OPTYPE_RET_COND;
            		else if (br_class_2.conditionality == bt9::BrClass::Conditionality::UNCONDITIONAL)
              		opType_2 = OPTYPE_RET_UNCOND;
					else {
           			opType_2 = OPTYPE_ERROR;
            		}
          		}
          		else if (br_class_2.directness == bt9::BrClass::Directness::INDIRECT) {
            		if (br_class_2.type == bt9::BrClass::Type::CALL) {
              			if (br_class_2.conditionality == bt9::BrClass::Conditionality::CONDITIONAL)
                			opType_2 = OPTYPE_CALL_INDIRECT_COND;
              			else if (br_class_2.conditionality == bt9::BrClass::Conditionality::UNCONDITIONAL)
                			opType_2 = OPTYPE_CALL_INDIRECT_UNCOND;
             		 	else {
                		opType_2 = OPTYPE_ERROR;
              			}
            		}
            		else if (br_class_2.type == bt9::BrClass::Type::JMP) {
              			if (br_class_2.conditionality == bt9::BrClass::Conditionality::CONDITIONAL)
                			opType_2 = OPTYPE_JMP_INDIRECT_COND;
              			else if (br_class_2.conditionality == bt9::BrClass::Conditionality::UNCONDITIONAL)
                			opType_2 = OPTYPE_JMP_INDIRECT_UNCOND;
              			else {
                			opType_2 = OPTYPE_ERROR;
              			}
            		}
            		else {
              			opType_2 = OPTYPE_ERROR;
            		}
          		}
				else if (br_class_2.directness == bt9::BrClass::Directness::DIRECT) {
	                if (br_class_2.type == bt9::BrClass::Type::CALL) {
             			if (br_class_2.conditionality == bt9::BrClass::Conditionality::CONDITIONAL) {
                			opType_2 = OPTYPE_CALL_DIRECT_COND;
              			}
              		else if (br_class_2.conditionality == bt9::BrClass::Conditionality::UNCONDITIONAL) {
               			opType_2 = OPTYPE_CALL_DIRECT_UNCOND;
              			}
              		else {
                		opType_2 = OPTYPE_ERROR;
              			}
            		}
            		else if (br_class_2.type == bt9::BrClass::Type::JMP) {
              			if (br_class_2.conditionality == bt9::BrClass::Conditionality::CONDITIONAL) {
                			opType_2 = OPTYPE_JMP_DIRECT_COND;
              			}
              			else if (br_class_2.conditionality == bt9::BrClass::Conditionality::UNCONDITIONAL) {
                			opType_2 = OPTYPE_JMP_DIRECT_UNCOND;
              			}
              			else {
                			opType_2 = OPTYPE_ERROR;
              			}
            		}
            		else {
              			opType_2 = OPTYPE_ERROR;
            		}
          		}
          		else {
            		opType_2 = OPTYPE_ERROR;
          		}


          		PC_2 = it_2->getSrcNode()->brVirtualAddr();			
			
				branchTaken_2 = it_2->getEdge()->isTakenPath();
		        branchTarget_2 = it_2->getEdge()->brVirtualTarget();


         		if (opType_2 == OPTYPE_ERROR) {
            		if (it_2->getSrcNode()->brNodeIndex()) { //only fault if it isn't the first node in the graph (fake branch)
             		 fprintf(stderr, "OPTYPE_ERROR\n");
              		printf("OPTYPE_ERROR\n");
              		exit(-1); //this should never happen, if it does please email CBP org chair.
            		}
          		}
          		else if (br_class_2.conditionality == bt9::BrClass::Conditionality::CONDITIONAL) { //JD2_17_2016 call UpdatePredictor() for all branches that decode as conditional
            //printf("COND ");
            		bool predDir_2 = false;

            		predDir_2 = brpred->GetPrediction(PC_2);
            		brpred->UpdatePredictor(PC_2, opType_2, branchTaken_2, predDir_2, branchTarget_2);

            		if(predDir_2 != branchTaken_2){
              		numMispred_2++; // update mispred stats
            		}
            		cond_branch_instruction_counter_2++;

          		}
          		else if (br_class_2.conditionality == bt9::BrClass::Conditionality::UNCONDITIONAL) { // for predictors that want to track unconditional branches
            		uncond_branch_instruction_counter_2++;
            		brpred->TrackOtherInst(PC_2, opType_2, branchTaken_2, branchTarget_2);
          		}
          		else {
					fprintf(stderr, "CONDITIONALITY ERROR\n");
           			printf("CONDITIONALITY ERROR\n");
            		exit(-1); //this should never happen, if it does please email CBP org chair.
          		}
			}
       		catch (const std::out_of_range & ex) {
          	std::cout << ex.what() << '\n';
          	break;
        	}
			if(((counter_2 % 10000) == 0) && (counter_2 !=0)){
				printf("Context Switching now! P1 mispredict rate before switching is \t : %10.4f \n",   1000.0*(double)(numMispred_2)/(double)(numIter_2));
                fflush(stdout);
				resume_it = it_2++;
				counter_2++;
				break;
			}
			counter_2++;
     	}//for (auto it = bt9_reader.begin(); it != bt9_reader.end(); ++it)		
	}
	//SUCHITA
        try {
          bt9::BrClass br_class = it->getSrcNode()->brClass();

//JD2_2_2016 break down branch instructions into all possible types
          opType = OPTYPE_ERROR; 

          if ((br_class.type == bt9::BrClass::Type::UNKNOWN) && (it->getSrcNode()->brNodeIndex())) { //only fault if it isn't the first node in the graph (fake branch)
            opType = OPTYPE_ERROR; //sanity check
          }
          else if (br_class.type == bt9::BrClass::Type::RET) {
            if (br_class.conditionality == bt9::BrClass::Conditionality::CONDITIONAL)
              opType = OPTYPE_RET_COND;
            else if (br_class.conditionality == bt9::BrClass::Conditionality::UNCONDITIONAL)
              opType = OPTYPE_RET_UNCOND;
            else {
              opType = OPTYPE_ERROR;
            }
          }
          else if (br_class.directness == bt9::BrClass::Directness::INDIRECT) {
            if (br_class.type == bt9::BrClass::Type::CALL) {
              if (br_class.conditionality == bt9::BrClass::Conditionality::CONDITIONAL)
                opType = OPTYPE_CALL_INDIRECT_COND;
              else if (br_class.conditionality == bt9::BrClass::Conditionality::UNCONDITIONAL)
                opType = OPTYPE_CALL_INDIRECT_UNCOND;
              else {
                opType = OPTYPE_ERROR;
              }
            }
            else if (br_class.type == bt9::BrClass::Type::JMP) {
              if (br_class.conditionality == bt9::BrClass::Conditionality::CONDITIONAL)
                opType = OPTYPE_JMP_INDIRECT_COND;
              else if (br_class.conditionality == bt9::BrClass::Conditionality::UNCONDITIONAL)
                opType = OPTYPE_JMP_INDIRECT_UNCOND;
              else {
                opType = OPTYPE_ERROR;
              }
            }
            else {
              opType = OPTYPE_ERROR;
            }
          }
          else if (br_class.directness == bt9::BrClass::Directness::DIRECT) {
            if (br_class.type == bt9::BrClass::Type::CALL) {
              if (br_class.conditionality == bt9::BrClass::Conditionality::CONDITIONAL) {
                opType = OPTYPE_CALL_DIRECT_COND;
              }
              else if (br_class.conditionality == bt9::BrClass::Conditionality::UNCONDITIONAL) {
                opType = OPTYPE_CALL_DIRECT_UNCOND;
              }
              else {
                opType = OPTYPE_ERROR;
              }
            }
            else if (br_class.type == bt9::BrClass::Type::JMP) {
              if (br_class.conditionality == bt9::BrClass::Conditionality::CONDITIONAL) {
                opType = OPTYPE_JMP_DIRECT_COND;
              }
              else if (br_class.conditionality == bt9::BrClass::Conditionality::UNCONDITIONAL) {
                opType = OPTYPE_JMP_DIRECT_UNCOND;
              }
              else {
                opType = OPTYPE_ERROR;
              }
            }
            else {
              opType = OPTYPE_ERROR;
            }
          }
          else {
            opType = OPTYPE_ERROR;
          }

  
          PC = it->getSrcNode()->brVirtualAddr();

          branchTaken = it->getEdge()->isTakenPath();
          branchTarget = it->getEdge()->brVirtualTarget();


          if (opType == OPTYPE_ERROR) { 
            if (it->getSrcNode()->brNodeIndex()) { //only fault if it isn't the first node in the graph (fake branch)
              fprintf(stderr, "OPTYPE_ERROR\n");
              printf("OPTYPE_ERROR\n");
              exit(-1); //this should never happen, if it does please email CBP org chair.
            }
          }
          else if (br_class.conditionality == bt9::BrClass::Conditionality::CONDITIONAL) { //JD2_17_2016 call UpdatePredictor() for all branches that decode as conditional
            //printf("COND ");


            bool predDir = false;

            predDir = brpred->GetPrediction(PC);
            brpred->UpdatePredictor(PC, opType, branchTaken, predDir, branchTarget); 

            if(predDir != branchTaken){
              numMispred++; // update mispred stats
            }
            cond_branch_instruction_counter++;

          }
          else if (br_class.conditionality == bt9::BrClass::Conditionality::UNCONDITIONAL) { // for predictors that want to track unconditional branches
            uncond_branch_instruction_counter++;
            brpred->TrackOtherInst(PC, opType, branchTaken, branchTarget);
          }
          else {
            fprintf(stderr, "CONDITIONALITY ERROR\n");
            printf("CONDITIONALITY ERROR\n");
            exit(-1); //this should never happen, if it does please email CBP org chair.
          }

/************************************************************************************************************/
        }
        catch (const std::out_of_range & ex) {
          std::cout << ex.what() << '\n';
          break;
        }
      
	counter++;

      } //for (auto it = bt9_reader.begin(); it != bt9_reader.end(); ++it)


    ///////////////////////////////////////////
    //print_stats
    ///////////////////////////////////////////

    //NOTE: competitors are judged solely on MISPRED_PER_1K_INST. The additional stats are just for tuning your predictors.

      printf("  TRACE \t : %s" , trace_path.c_str()); 
      printf("  NUM_INSTRUCTIONS            \t : %10llu",   total_instruction_counter);
      printf("  NUM_BR                      \t : %10llu",   branch_instruction_counter-1); //JD2_2_2016 NOTE there is a dummy branch at the beginning of the trace...
      printf("  NUM_UNCOND_BR               \t : %10llu",   uncond_branch_instruction_counter);
      printf("  NUM_CONDITIONAL_BR          \t : %10llu",   cond_branch_instruction_counter);
      printf("  NUM_MISPREDICTIONS          \t : %10llu",   numMispred);
      printf("  MISPRED_PER_1K_INST         \t : %10.4f",   1000.0*(double)(numMispred)/(double)(total_instruction_counter));
      printf("\n");
}



